;; Author: Christopher Olsen

;; Project Euler Problem 12
;;
;; Highly Divisible Triangle Number
;;
;; The sequence of triangle numbers is generated by adding the natural 
;; numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
;;  The first ten terms would be:
;;
;; 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
;;
;; Let us list the factors of the first seven triangle numbers:
;;
;;      1: 1
;;      3: 1,3
;;      6: 1,2,3,6
;;     10: 1,2,5,10
;;     15: 1,3,5,15
;;     21: 1,3,7,21
;;     28: 1,2,4,7,14,28
;;
;; We can see that 28 is the first triangle number to have over five divisors.
;;
;; What is the value of the first triangle number to have over five hundred 
;; divisors?


;; The Plan
;;
;; Bring back the prime factor loop from problem 3 and use The Fundamental
;; Theorem Of Arithmetic (and some other math) to count factors
;; Also leverage laziness
;; 

(def triangle-seq
  (map #(/ (* % (+ % 1)) 2) (iterate inc 1)))

(defn factors-from [lower number]
  ;; using zero? and rem instead of (= 0 (mod x y)) is a decent amount faster
  (cond (= number 1) []
        (zero? (rem number lower)) (cons lower (factors-from lower
                                                           (/ number lower)))
        :else (recur (inc lower) number)))


;; this outputs an answer of the form (2 2 2 2 3 3 5) or 2^4 + 3^2 + 5^1
;; the number of factors is (4+1)(2+1)(1+1) or for the general series
;; 2^a + 3^b + 5^c + 7^d... the number of even divisors is 
;; (a+1)(b+1)(c+1)(d+1)... (this is not an obvious trick)
;;
;; for details see: http://math.stackexchange.com/questions/96793/counting-total-factors-given-multiplicity-of-all-prime-factors
;;


(defn count-powers
  ;; again, showing it's better in Clojure to use the built-in's instead of
  ;; rolling your own functions.  Runs almost twice as fast as a self-rolled
  ;; version using loop/recur.
  [divisor-list]
  (reduce * (map #(inc %) (vals (frequencies divisor-list)))))

(defn divisor-count
  [number]
  (count-powers (factors-from 2 number)))

(time (divisor-count 345676898))
;; "Elapsed time: 7078.584505 msecs"
;; 8


(defn prob-12
  [limit]
  (first (drop-while #(<= (divisor-count %) limit) triangle-seq)))

(time (prob-12 10))
;; "Elapsed time: 5.314223 msecs"
;; 120

(time (prob-12 100))
;; "Elapsed time: 30.447098 msecs"
;; 73920

(time (prob-12 200))
;; "Elapsed time: 251.169649 msecs"
;; 2031120

(time (prob-12 400))
;; "Elapsed time: 1972.647849 msecs"
;; 17907120

(time (prob-12 500))
;; "Elapsed time: 7622.664447 msecs"
;; 76576500




;; ;; ****  code that ended up not being used ****
;;
;; ;; The Plan
;; ;;
;; ;; - write a divisors function that counts divisors
;; ;; - step through the triangle sequence counting divisors of each
;; ;;
;; ;; - the minimum number with 
;;
;; (defn divisors
;;   [number]
;;   (let [the-max (/ number 2)]
;;     (loop [current 1
;;            count 1]
;;       (cond (> current the-max) count
;;             (zero? (mod number current)) (recur (inc current) (inc count))
;;             :else (recur (inc current) count)))))
;;
;; (defn triangle-number
;;   [number]
;;   (/ (* number (+ number 1)) 2))
;;
;; (defn- triangle-number2
;;   [number]
;;   (reduce + (range 1 (inc number))))
